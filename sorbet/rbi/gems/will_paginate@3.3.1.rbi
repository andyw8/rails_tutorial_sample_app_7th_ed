# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `will_paginate` gem.
# Please instead update this file by running `bin/tapioca gem will_paginate`.

class ActiveRecord::Associations::CollectionProxy < ::ActiveRecord::Relation; end

class ActiveRecord::Base
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::Serialization
  extend ::WillPaginate::PerPage
  extend ::WillPaginate::PerPage::Inheritance
  extend ::WillPaginate::ActiveRecord::Pagination
  extend ::WillPaginate::ActiveRecord::BaseMethods
end

class ActiveRecord::Relation
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::WillPaginate::ActiveRecord::Pagination
end

# You will paginate!
#
# source://will_paginate//lib/will_paginate.rb#2
module WillPaginate
  extend ::WillPaginate::PerPage

  class << self
    # An idemptotent coercion method
    #
    # source://will_paginate//lib/will_paginate/page_number.rb#47
    def PageNumber(value, name = T.unsafe(nil)); end
  end
end

# = Paginating finders for ActiveRecord models
#
# WillPaginate adds +paginate+, +per_page+ and other methods to
# ActiveRecord::Base class methods and associations.
#
# In short, paginating finders are equivalent to ActiveRecord finders; the
# only difference is that we start with "paginate" instead of "find" and
# that <tt>:page</tt> is required parameter:
#
#   @posts = Post.paginate :all, :page => params[:page], :order => 'created_at DESC'
#
# source://will_paginate//lib/will_paginate/active_record.rb#18
module WillPaginate::ActiveRecord; end

# source://will_paginate//lib/will_paginate/active_record.rb#180
module WillPaginate::ActiveRecord::BaseMethods
  # Wraps +find_by_sql+ by simply adding LIMIT and OFFSET to your SQL string
  # based on the params otherwise used by paginating finds: +page+ and
  # +per_page+.
  #
  # Example:
  #
  #   @developers = Developer.paginate_by_sql ['select * from developers where salary > ?', 80000],
  #                          :page => params[:page], :per_page => 3
  #
  # A query for counting rows will automatically be generated if you don't
  # supply <tt>:total_entries</tt>. If you experience problems with this
  # generated SQL, you might want to perform the count manually in your
  # application.
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#195
  def paginate_by_sql(sql, options); end
end

# source://will_paginate//lib/will_paginate/active_record.rb#142
module WillPaginate::ActiveRecord::Pagination
  # source://will_paginate//lib/will_paginate/active_record.rb#159
  def page(num); end

  # source://will_paginate//lib/will_paginate/active_record.rb#143
  def paginate(options); end
end

# makes a Relation look like WillPaginate::Collection
#
# source://will_paginate//lib/will_paginate/active_record.rb#20
module WillPaginate::ActiveRecord::RelationMethods
  include ::WillPaginate::CollectionMethods

  # source://will_paginate//lib/will_paginate/active_record.rb#114
  def clone; end

  # source://will_paginate//lib/will_paginate/active_record.rb#81
  def count(*args); end

  # Returns the value of attribute current_page.
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#23
  def current_page; end

  # Sets the attribute current_page
  #
  # @param value the value to set the attribute current_page to.
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#23
  def current_page=(_arg0); end

  # overloaded to be pagination-aware
  #
  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#106
  def empty?; end

  # fix for Rails 3.0
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#54
  def find_last(*args); end

  # dirty hack to enable `first` after `limit` behavior above
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#43
  def first(*args); end

  # TODO: solve with less relation clones and code dups
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#33
  def limit(num); end

  # source://will_paginate//lib/will_paginate/active_record.rb#62
  def offset(value = T.unsafe(nil)); end

  # source://will_paginate//lib/will_paginate/active_record.rb#26
  def per_page(value = T.unsafe(nil)); end

  # workaround for Active Record 3.0
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#119
  def scoped(options = T.unsafe(nil)); end

  # workaround for Active Record 3.0
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#97
  def size; end

  # source://will_paginate//lib/will_paginate/active_record.rb#123
  def to_a; end

  # source://will_paginate//lib/will_paginate/active_record.rb#68
  def total_entries; end

  # Sets the attribute total_entries
  #
  # @param value the value to set the attribute total_entries to.
  #
  # source://will_paginate//lib/will_paginate/active_record.rb#24
  def total_entries=(_arg0); end

  private

  # source://will_paginate//lib/will_paginate/active_record.rb#135
  def copy_will_paginate_data(other); end
end

# = The key to pagination
# Arrays returned from paginating finds are, in fact, instances of this little
# class. You may think of WillPaginate::Collection as an ordinary array with
# some extra properties. Those properties are used by view helpers to generate
# correct page links.
#
# WillPaginate::Collection also assists in rolling out your own pagination
# solutions: see +create+.
#
# If you are writing a library that provides a collection which you would like
# to conform to this API, you don't have to copy these methods over; simply
# make your plugin/gem dependant on this library and do:
#
#   require 'will_paginate/collection'
#   # WillPaginate::Collection is now available for use
#
# source://will_paginate//lib/will_paginate/collection.rb#52
class WillPaginate::Collection < ::Array
  include ::WillPaginate::CollectionMethods

  # Arguments to the constructor are the current page number, per-page limit
  # and the total number of entries. The last argument is optional because it
  # is best to do lazy counting; in other words, count *conditionally* after
  # populating the collection using the +replace+ method.
  #
  # @return [Collection] a new instance of Collection
  #
  # source://will_paginate//lib/will_paginate/collection.rb#61
  def initialize(page, per_page = T.unsafe(nil), total = T.unsafe(nil)); end

  # Returns the value of attribute current_page.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#55
  def current_page; end

  # Current offset of the paginated collection. If we're on the first page,
  # it is always 0. If we're on the 2nd page and there are 30 entries per page,
  # the offset is 30. This property is useful if you want to render ordinals
  # side by side with records in the view: simply start with offset + 1.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#104
  def offset; end

  # Returns the value of attribute per_page.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#55
  def per_page; end

  # This is a magic wrapper for the original Array#replace method. It serves
  # for populating the paginated collection after initialization.
  #
  # Why magic? Because it tries to guess the total number of entries judging
  # by the size of given array. If it is shorter than +per_page+ limit, then we
  # know we're on the last page. This trick is very useful for avoiding
  # unnecessary hits to the database to do the counting after we fetched the
  # data for the current page.
  #
  # However, after using +replace+ you should always test the value of
  # +total_entries+ and set it to a proper value if it's +nil+. See the example
  # in +create+.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#124
  def replace(array); end

  # Returns the value of attribute total_entries.
  #
  # source://will_paginate//lib/will_paginate/collection.rb#55
  def total_entries; end

  # source://will_paginate//lib/will_paginate/collection.rb#108
  def total_entries=(number); end

  class << self
    # Just like +new+, but yields the object after instantiation and returns it
    # afterwards. This is very useful for manual pagination:
    #
    #   @entries = WillPaginate::Collection.create(1, 10) do |pager|
    #     result = Post.find(:all, :limit => pager.per_page, :offset => pager.offset)
    #     # inject the result array into the paginated collection:
    #     pager.replace(result)
    #
    #     unless pager.total_entries
    #       # the pager didn't manage to guess the total count, do it manually
    #       pager.total_entries = Post.count
    #     end
    #   end
    #
    # The possibilities with this are endless. For another example, here is how
    # WillPaginate used to define pagination for Array instances:
    #
    #   Array.class_eval do
    #     def paginate(page = 1, per_page = 15)
    #       WillPaginate::Collection.create(page, per_page, size) do |pager|
    #         pager.replace self[pager.offset, pager.per_page].to_a
    #       end
    #     end
    #   end
    #
    # The Array#paginate API has since then changed, but this still serves as a
    # fine example of WillPaginate::Collection usage.
    #
    # @yield [pager]
    #
    # source://will_paginate//lib/will_paginate/collection.rb#94
    def create(page, per_page, total = T.unsafe(nil)); end
  end
end

# Any will_paginate-compatible collection should have these methods:
#
#   current_page, per_page, offset, total_entries, total_pages
#
# It can also define some of these optional methods:
#
#   out_of_bounds?, previous_page, next_page
#
# This module provides few of these methods.
#
# source://will_paginate//lib/will_paginate/collection.rb#14
module WillPaginate::CollectionMethods
  # current_page + 1 or nil if there is no next page
  #
  # source://will_paginate//lib/will_paginate/collection.rb#25
  def next_page; end

  # Helper method that is true when someone tries to fetch a page with a
  # larger number than the last page. Can be used in combination with flashes
  # and redirecting.
  #
  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/collection.rb#32
  def out_of_bounds?; end

  # current_page - 1 or nil if there is no previous page
  #
  # source://will_paginate//lib/will_paginate/collection.rb#20
  def previous_page; end

  # source://will_paginate//lib/will_paginate/collection.rb#15
  def total_pages; end
end

# source://will_paginate//lib/will_paginate/i18n.rb#2
module WillPaginate::I18n
  # source://will_paginate//lib/will_paginate/i18n.rb#11
  def will_paginate_translate(keys, options = T.unsafe(nil), &block); end

  class << self
    # source://will_paginate//lib/will_paginate/i18n.rb#7
    def load_path; end

    # source://will_paginate//lib/will_paginate/i18n.rb#3
    def locale_dir; end
  end
end

# a module that page number exceptions are tagged with
#
# source://will_paginate//lib/will_paginate/page_number.rb#5
module WillPaginate::InvalidPage; end

# integer representing a page number
#
# source://will_paginate//lib/will_paginate/page_number.rb#9
class WillPaginate::PageNumber < ::Numeric
  extend ::Forwardable

  # @return [PageNumber] a new instance of PageNumber
  #
  # source://will_paginate//lib/will_paginate/page_number.rb#14
  def initialize(value, name); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def *(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def +(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def -(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def /(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def <=>(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def ==(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def coerce(*args, **_arg1, &block); end

  # source://will_paginate//lib/will_paginate/page_number.rb#32
  def inspect; end

  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/page_number.rb#40
  def is_a?(klass); end

  # @return [Boolean]
  #
  # source://will_paginate//lib/will_paginate/page_number.rb#40
  def kind_of?(klass); end

  # source://will_paginate//lib/will_paginate/page_number.rb#26
  def to_i; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_json(*args, **_arg1, &block); end

  # source://will_paginate//lib/will_paginate/page_number.rb#36
  def to_offset(per_page); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def to_s(*args, **_arg1, &block); end
end

# a value larger than this is not supported in SQL queries
#
# source://will_paginate//lib/will_paginate/page_number.rb#10
WillPaginate::PageNumber::BIGINT = T.let(T.unsafe(nil), Integer)

# source://will_paginate//lib/will_paginate/per_page.rb#2
module WillPaginate::PerPage
  # source://will_paginate//lib/will_paginate/per_page.rb#3
  def per_page; end

  # source://will_paginate//lib/will_paginate/per_page.rb#7
  def per_page=(limit); end

  class << self
    # @private
    #
    # source://will_paginate//lib/will_paginate/per_page.rb#11
    def extended(base); end
  end
end

# source://will_paginate//lib/will_paginate/per_page.rb#15
module WillPaginate::PerPage::Inheritance
  # source://will_paginate//lib/will_paginate/per_page.rb#16
  def inherited(subclass); end
end

# source://will_paginate//lib/will_paginate/railtie.rb#6
class WillPaginate::Railtie < ::Rails::Railtie
  class << self
    # source://will_paginate//lib/will_paginate/railtie.rb#24
    def setup_actioncontroller; end
  end
end

# source://will_paginate//lib/will_paginate/railtie.rb#61
module WillPaginate::Railtie::ControllerRescuePatch
  # source://will_paginate//lib/will_paginate/railtie.rb#62
  def rescue_from(*args, **kwargs, &block); end
end

# Extending the exception handler middleware so it properly detects
# WillPaginate::InvalidPage regardless of it being a tag module.
#
# source://will_paginate//lib/will_paginate/railtie.rb#33
module WillPaginate::Railtie::ShowExceptionsPatch
  extend ::ActiveSupport::Concern

  # source://will_paginate//lib/will_paginate/railtie.rb#39
  def status_code_with_paginate(exception = T.unsafe(nil)); end
end
